#####静态工厂方法
```
valueOf 不太严格的讲，该方法返回的实例与它的参数具有相同的值。这样的静态工厂方法实际上是类型转化方法
of valueOf的一种更为简洁的替代
getInstance 返回的实例是通过方法的参数来描述的，但是不能够说与参数具有同样的值。对于Singleton来说，该方法没有参数，并返回唯一的实例
newInstance 像getInstance一样，但newInstance能够确保返回的每个实例都与所有其他实例不同
getType 与getInstance一样，Type表示工厂方法所返回的对象类型
newTYpe 与newInstance一样，Type表示工厂方法所返回的对象类型

```
![img](/Users/iss/sourceCode/spark/sjmsDemo/picture/2222.png)

#####遇到多个构造器参数时考虑用构建器

```
重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难编写，并且仍然难以阅读
把类做成不可变的

如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择，特别是当大多数参数都是可选时
```

#####用私有构造器或者枚举类型强化Singleton的属性
```$xslt

```

#####通过私有构造器强化不可实例化的能力
```$xslt
工具类不希望被实例化，实例对它没有任何意义。然而，在缺少显示构造器的情况下，编译器会自动提供一个公有的、无参的缺省构造器
显示的私有的构造器，但这种用法有个副作用就是它不能子类化
```

#####避免创建不必要的对象
```$xslt
一般来说，最好能重用对象而不是在每次需要的时候就创建相同功能的对象。重用方式既快速，又流行。如果是不可变对象，它始终可重用(如：字符串池)。
除了重用不可变对象外，也可以重用那些已知不会被修改的可变对象
对于同时提供了静态工程方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创造不必要的对象。
要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱


一个是需要占用较大内存空间的对象，反复分配释放会消耗很多资源。
还有一类就是比较消耗io等数据库，网络连接等对象，还有线程等
```

#####消除过期对象引用
```$xslt
清空对象引用应该是一种例外，而不是一种规范行为
一般而言，只要类自己管理内存，程序员就应该警惕内存泄露问题。一旦元素被释放掉了，则该元素中包含的任何对象引用都应该被清空
内存泄露的另一个常见来源是缓存、监听器和其他回调  可以利用弱引用(WeakHashMap)来解决

 修复方法也很简单：一旦对象引用已经过期，只需要清空这些引用即可
```

#####避免使用终结方法
```$xslt
如果子类实现者覆盖了父类的终结方法，子类终结方法就必须手工调用超类的终结方法。你应该在一个try块中终结子类，
并在相应的finally块中调用超类的终结方法。这样可以保证：即使子类的终结过程抛出异常，超类的终结方法也会得到执行。反之亦然
```

#####覆盖equals时请遵守通用约定
```
任何一个类覆盖所有非final方法(equals、hashCode、toString、clone、和finalize)都应遵守明确通用约定，否则的话，其他依赖于
这些约定的类(HashMap和HashSet)就无法和该类正常的工作

需要重写equals: 值类(仅仅表示一个值的类)相等的情况且超类没有覆盖equals以实现期望的行为(程序员利用equals方法来比较值对象的引用时，希望知道它们在逻辑上
是否相等，而不是想了解他们是否指向同一个对象)
还有一种 值类 不需要覆盖equals方法，即用实例受控确保 每个值至多只存在一个对象 的类。枚举就属于这种类。对于这样的类而言，逻辑相同与对象相同是同一回事，因为
Object的equals方法等同于逻辑意义上的equals方法

另外相同的对象必须要有相同的hashCode，所有重写equals的时候往往需要重写hashCode

许多类，包括所有的集合类在内，都依赖于传递给它们的对象是否遵守了equals约定

reflexivity 自反性  x.equals(x) true
symmetry 对称性     x.equals(y) true y.equals(x) true
transitivity 传递性 x.equals(y) true y.equals(z) true x.equals(z) true
consistency 一致性  如果两个对象相等，它们就必须始终保持相等，除非至少有一个对象被修改了
非空性 

我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定(纯粹是子类与子类之间的equals是ok的，即使可以直接创建超类的实例，只要超类的实例不参与比较即可),
但可以在抽象类的子类中增加新的值组件，而不会违反equals约定。

一旦违反了equals约定，当其他对象面对你的对象事，你完全不知道这些对象的行为会怎么样

覆盖equals的时候总要覆盖hashCode

复合优先于继承

```
 #####覆盖equals时总要覆盖hashCode
 ```
 equals相等的两个对象 hashCode一定相等，hashCode相等，equals不一定相等。
 
 如果不覆盖的话，违反 Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和HashTable
 
 给不同的对象产生不同的hashCode有可能提高散列表的性能
 
 如果你觉得这种类型的大多数对象会被用做散列键，就应该在创建实例的时候计算散列码。否则可以选择 延迟初始化 散列码，一直到 hashCode被第一次
 调用的时候才初始化
 
 不要试图从散列码计算中排除掉一个对象的关键部分来提高性能
 ```
 #####始终要覆盖 toString
 ```
 在实际应用中，toString方法应该返回对象中包含的所有值得关注的信息
 ```

 ##### 谨慎的覆盖 clone

 ##### 考虑实现 Comparable 接口
 ```
 Java类库中所有的值类都实现了 Comparable 接口。如果你正在编写一个值类，它具有非常明显的内在排序关系
 ```



### 类与接口

 ##### 使类和成员的可访问性最小

 ```
 1.尽可能的使每个类或者成员不被外界访问
  对于顶层的(非嵌套)类和接口，只能有两种可能的访问级别：包私有和public
  通过把类或接口做成包私有，以后对它进行修改、删除等，无需担心会影响到现有的客户端程序，如果你把它做成公有的，就有责任永远支持它，以保证兼容性
  如果一个包级私有的顶层类(或接口) 只是在某一个类内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类
 ```
![img](/Users/iss/sourceCode/spark/sjmsDemo/picture/1111.png)

```
当我在设计一个类的时候，我应该考虑这个类的可见性以及其属性、方法、变量的可见性

公有类受保护的成员也代表了该类对于某个实现细节的公开承诺，也应该尽量少用
当你仔细设计了类的公有API之后，其他所有的都应变成私有的

有一条规则：如果方法覆盖了超类中的一个方法，子类中的访问级别不允许低于超类的访问级别。这样可以确保在可使用超类实例的地方也都可以使用子类的实例

实例域决不能是公有的，也适用于静态域，但通过公有的静态final域来暴露 (不可变)常量 是例外的

除了公有静态 final域外,公有类都不应该包含公有域，并且要确保公有静态final域所引用的对象都是不可变的
```





```
如果类可以在它所在的包的外部进行访问，就提供访问方法，已保留将来改变该类的内部表示法的灵活性(主要是将来改动时，客户端已经遍布老代码了)，但如果类是包级私有的或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。
```

##### 使可变性最小化

```
使类成为不可变类的五条规则：
1.不提供任何会修改对象状态的方法
2.保证类不会被扩展  一般将类设置为final
3.使所有域final
4.所有域私有
5.确保任何可变组件互斥访问  如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用

不可变对象本质上是线程安全的，它不要求同步

让不可变类的所有构造器都编程私有的或者包级私有的，并添加公有的静态工厂
```

##### 复合优先继承

```
继承打破了封装性。超类的实现有可能会随着发行版本的不同而有所变化，子类有可能会遭到破坏，即使子类代码完全没有改变

复合的话回调会有问题(待验证)

只有当子类真正是超类的子类型时，才适合用继承。确实存在 is-a 的关系时，才应该继承
```



##### 要么为继承而设计，并提供文档说明，要么就禁止继承

```
为了允许继承，类还必须遵守一些约束。构造器决不能调用可被覆盖的方法，无论是直接还是间接调用。
超类的构造器在子类的构造器之前运行，所以子类中覆盖版本的方法将会在子类的构造器之前就先被调用。如果该覆盖版本的方法依赖于子类构造器所执行的任何初始化工作，该方法将不会如预期般的执行

如果你决定在一个为了继承而设计的类中实现 Cloneable或者Serializable接口，应该意识到 clone和 readObject方法在行为上非常类似于构造器，所以无论是clone 还是 readObject，都不可以调用可覆盖的方法，不管是直接还是间接的方式

禁止子类化方法：
1.final
2.构造器私有或包私有，并增加一些公有的静态工厂类
```



##### 18.接口优先于抽象类

```
因为 java 只允许单继承
```

##### 接口只定义类型



```
检查参数的有效性
```

```
目标是四个参数或者更少
缩短过长参数列表：
1.把方法分解成多个方法
2.创建辅助类 这个辅助类一般为静态成员类
3.从对象构建到方法调用都采用 Builder模式

对于 boolean参数，要优先使用两个元素的枚举类型
```



```
返回零长度的数组或者集合，而不是null
```



```
为所有到处的API元素编写文档注释
```



```
通过接口引用对象
```



```
只针对异常的情况使用异常，它们永远不应用与正常的控制流
```



```
可恢复的情况使用受检异常，对编程错误使用运行时异常
```

```
如果一个方法可能抛出多个异常，则不要使用快捷方式声明它会抛出这些异常的某个超类。这样的声明不仅没有为程序员提供关于 这个方法能够抛出哪些异常 的任何指导信息，而且大大地妨碍了该方法的使用，因为它实际上掩盖了该方法在同样的执行环境下可能抛出的任何其他异常
```







 #####关于比较

 ```
 优先比较最不可能一致的
 ```





CallBack charpter02.test02

#######getClass()
```
System.out.println("this.getClass()== "+this.getClass());
System.out.println("super.getClass()== "+super.getClass());
都指的是本类
Class()是属于类的方法是在编译时确定的，getClass()是属于对象的方法是运行时确定的
```
