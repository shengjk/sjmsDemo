哈夫曼(Huffman)编码
利用二叉树来压缩数据

二叉树：
    通常结合了有序数组和链表的优点，查找、插入、删除都很快
   
    叶节点：没有子节点的节点称为叶子节点或者叶节点
    子树：包括它和它所有的子节点
    层：从0开始的
    访问一个节点：意味着对这个节点做某种操作，显示节点，把节点写入文件，或其他别的操作
    
    二叉搜索树：左子节点的关键字小于这个节点，右子节点的关键字大于等于这个节点
    在二叉树中得到最大值和最小值是轻而易举的事情，最左节点是最小值，最右节点为最大值
    
    用数组来表示树
    
    哈夫曼(Huffman)编码  使用二叉树以令人惊讶的方式来压缩数据


红黑树：
    解决非平衡树问题
    红黑规则：
    1.任何一个节点都有颜色，黑色或者红色
    2.根节点是黑色的
    3.父子节点之间不能出现两个连续的红节点
    4.任何一个节点向下遍历到其子孙的叶节点，所经过的黑节点个数必须相等
    5.空节点被认为是黑色的
    旋转操作：目的是使节点颜色符合定义，让RBTree的高度达到平衡
    查找操作与BST一样
    插入修复：新插入的节点是红色的，只有在父节点也为红色时才需要插入修复

哈希表：
    不论哈希表中有多少数据，插入和删除都是O(1)
    基于数组的，难以扩容，某些哈希表被填满后，性能下降的很严重。而且也没有一种简便的方法可以以任一顺序(如从小到大)遍历
    然而如果不需要遍历数据，并且可以提前预测数据量的大小，那么哈希表在速度和易用性方面无与伦比
    在开放地址法中，当装填因子超过二分之一或者三分之二后，性能下降的很快，在链地址法中，装填因子可以达到1以上，却对性能影响不大。
    因为，链地址法是更健壮的机制，特别是事先难以确定哈希表要存储多少数据时更是如此
    开放地址法：线性探测、二次探测(防止聚集，探测相隔较远的单元)、再哈希法
    链地址法：
    

堆：二叉树一种，通常是由树实现的  完全性(数组没有洞)、每个节点都比它的子节点大
    完全二叉树，也就是说除了树的最后一层节点不需要是满的，其他的每一层从左到右都是完全满的
    它常常用一个数组实现
    堆中的每一个节点都满足堆的条件，也就是说每一个节点的关键字都大于或者等于这个节点子节点的关键字
    这个介绍的堆，主要用来实现优先级队列，O(longN),尽管相对于数组实现的优先级队列删除的时间变慢了一些，但插入的时间快的多了，当速度非常重要，且有很多插入操作时，可以选择堆来实现优先级队列
    堆相比于二叉搜索树来说是弱序的。在堆中按序遍历堆是困难的，对于堆来说，只要求沿着从根到叶子的每一条路径，节点是降序排列的
    由于堆是弱序的，所以一些操作时困难的或者是不可能的，除了不支持遍历外也不能在堆上便利的查找指定的关键字，也能在少至O(logN)的时间内删除一个指定的关键字(这些操作可以通过查找数组的每一个单元来执行，O(N))
    堆的这种组织非常接近与无序，不过对于快速的移除最大节点的操作以及快速插入新节点的操作，这种顺序已经够了
    
    