#####复杂度
最差
最好
平均
一律按照最差的估计
冒泡、选择、插入 O(N^2) 空间复杂度O(1)
选择排序                               做不到稳定的
归并 O(N * logN)  空间 O(N)
快排 O(N * logN)  空间 O(logN) 随机快排   做不到稳定的
堆排序 O(N*logN) ,额外空间复杂度O(1)       做不到稳定性
荷兰国旗                                 做不到稳定性

不桶排序是个大类，分为计数排序和基数排序，不常用，与数据状况强相关
不是基于比较的排序 O(N) O(N)  稳定的排序
计数排序
基数排序

额外空间复杂度 
有限几个变量的空间 O(1)


任何递归行为都可以以非递归的形式表示

Master公式 计算递归复杂度：子过程的规模必须的一样
T(N)=aT(N/b)+O(n^d)
b 子问题的规模
a 发生了a次

#####对数器



#### 归并

![image-20181226175350884](./merge.png)

归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。



快排、对排



````java
给定一个数组arr,和一个数num，请把一个小于等于 num 的数放在数组左边，大于num的数放在数组右边

public static void main(String[] args) {
		int[] arr={0,-1,2,10,-2,11,100,21,2,0,-1};
		int num=10;
		int index=-1;
		for (int i = 0; i < arr.length; i++) {
			if (arr[i]>num){
			
			}else{
				index++;
				if (index!=i){
					int temp=arr[index];
					arr[index]=arr[i];
					arr[i]=temp;
				}
			}
		}
		
		for (int i = 0; i < arr.length; i++) {
			System.out.println(arr[i]);
		}
	}
````



荷兰国旗问题

堆排序：
堆就是完全二叉树(优先级队列)
数组--->完全二叉树  数组下标i 左 2*i+1 右 2*i+2 父 (i-1)/2

满二叉树 高度 增减 O(logN)
满二叉树属于完全二叉树(从左往右依次补齐)

大根堆 在完全二叉树中任何一颗子树的最大值都是这颗子树的头部 O(N)
小根堆 最小值 头部

建立大根堆 O(N) heapify O(logN)

堆排序就是利用堆的特性进行排序


优先级队列结构就是堆结构
建立堆的过程 O(N)
堆排序 O(N*logN) ,额外空间复杂度O(1)


排序的稳定性：
任何相同元素的值在原数组中的相对位置是不变的


冒泡排序：
大值往下沉

插入排序：
插扑克牌一样，后来的往之前的已经插好序的里面插

选择排序：做不到稳定的
已排序部分最大的值跟未排序部分选一个最小的比较然后交换


归并排序：
分治

荷兰国旗: 做不到稳定的

快排：做不到稳定的
分小于大于等于 三部分

堆排：做不到稳定性 

数组长度很短  插排  长度小于60       常数项低
数组长度比较大的并且还是基本数据类型 快排   不考虑算法稳定性
数组长度比较大的并且是自定义类  归并       考虑算法稳定性

算法需要考虑稳定性

一个有序的结构有一个可以去重的结构都会有比较的存在


二叉树
```$xslt
先序遍历：先访问根节点，然后访问左子树，然后访问右子树
```

### 思想是比较重要的
```$xslt
分区 分治
随机 绕开原始的数据状况
hash 绕开原始的数据状况
局部位置不好找的话，想想宏观，代替微观
双指针


工程上是一般不允许递归存在的，工程上准备一个递归函数的代价是比较大的，栈大小有限
```

大小堆代码


```
无序数组中，搜索效率低，有序数组中，插入效率低，不管是哪一种数组删除效率都很低

在给定的计算机/操作系统中，所有的引用，不管它指向谁，大小都是一样的
在链表中，寻找一个特定元素的唯一方法就是沿着这个元素的链一直向下寻找
```




##### 数据结构
```
对于链表来说基本上是提供了首位、末尾的删除、增加的方法，查找
```



```
三目运算 节俭代码
```

```$xslt
让他因为你想问题的方式而喜欢你
```

















**线性结构**：

数据元素之间存在一对一的关系

顺序存储 (存储元素的地址是连续的) 和链表存储  (存储元素的地址不一定连续)

 **数组、队列、链表、栈**

**非线性结构**：二维数组、对维数组、广义表、树结构、图结构



**稀疏数组**

队列：**有序列表 先入先出 可以通过数组或者链表来实现**
链表：**有序列表** ，分为带头结点的和没有头结点的，根据实际需求来确定



**哈希表**
快速插入和查找

哈希表是基于数据的，数组创建后难以扩展。

不适合以任何一种顺序遍历表中数据项

**解决哈希冲突**：

开发地址法：线性探测、二次探测(步骤是步数的平方)、再哈希(要求表的容量是一个质数)

用质数作为数组容量使得任何数想要整除它都是不可能的，因此探测序列最终会检查所有单元

链地址：

装填因子越大，链表越长

























